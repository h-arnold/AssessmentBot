# Test Writing Guidelines for AssessmentBot

This file provides Copilot-specific instructions for writing and maintaining tests in the AssessmentBot repository.

## Test Framework & Environment

- **Framework**: Vitest v3.2.4
- **Environment**: Node.js (no browser DOM by default). Use JSDOM (`jsdom` package) when testing HTML templates.
- **Module System**: Use ESM `import` syntax in test files (production code uses CommonJS)
- **Configuration**: `vitest.config.js` loads `tests/setupGlobals.js`

## Core Testing Principles

### 1. Test Logic, Not Services

**DO test:**
- Serialisation (`toJSON`/`fromJSON` round-trips)
- Hash generation and stability
- Business logic and validation
- State management and lifecycle
- Edge cases (null, empty, large data)

**DON'T test:**
- Google Apps Script services (SpreadsheetApp, DriveApp, etc.)
- Network calls or external APIs
- Timers tied to GAS runtime
- UI rendering

### 2. Use Factory Functions

Prefer factory functions from `tests/helpers/modelFactories.js` over inline object creation:

```javascript
// ✅ Good - use factory
import { createTaskDefinition } from '../helpers/modelFactories.js';
const task = createTaskDefinition({ index: 0, refContent: 'test' });

// ❌ Avoid - manual construction in tests
const task = new TaskDefinition({ taskTitle: 'Task 0', pageId: 'p0', index: 0 });
task.addReferenceArtifact({ type: 'TEXT', content: 'test' });
```

### 3. Use `fromJSON()` for Rehydration

Avoid calling constructors directly in tests. Use `fromJSON()` to rehydrate instances without triggering side effects:

```javascript
// ✅ Good - rehydrates without invoking constructor
import { Assignment } from '../../src/AdminSheet/Models/Assignment.js';
const assignment = Assignment.fromJSON({ courseId: 'c1', assignmentId: 'a1' });

// ❌ Bad - may throw because Classroom/ProgressTracker aren't defined in Node
// const assignment = new Assignment('courseId', 'assignmentId');
```

### 4. Mock Google Apps Script Globals

Use `tests/__mocks__/googleAppsScript.js` and `tests/helpers/mockFactories.js` for GAS mocks:

```javascript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mockPropertiesService, mockSpreadsheetApp } from '../helpers/mockFactories.js';

describe('MyComponent', () => {
  beforeEach(() => {
    globalThis.PropertiesService = mockPropertiesService();
    globalThis.SpreadsheetApp = mockSpreadsheetApp();
  });

  afterEach(() => {
    delete globalThis.PropertiesService;
    delete globalThis.SpreadsheetApp;
  });
});
```

### 5. Clean Up Singleton State

Always reset singleton state between tests to prevent cross-test pollution:

```javascript
import { afterEach } from 'vitest';
import { ConfigurationManager } from '../../src/AdminSheet/ConfigurationManager/ConfigurationManager.js';

afterEach(() => {
  ConfigurationManager.resetForTests();
});
```

### 6. Test File Organisation

```
tests/
├── __mocks__/           # Shared GAS mock implementations
├── mocks/               # Domain-specific mocks
├── helpers/             # Test utilities & factories
│   ├── mockFactories.js     # GAS mock factories
│   ├── modelFactories.js    # Domain model factories
│   └── testUtils.js         # Generic test helpers
├── models/              # Model tests (serialisation, validation)
├── singletons/          # Singleton pattern & lifecycle tests
├── parsers/             # Document parser tests
├── requestHandlers/     # API handler tests
├── ui/                  # UI template tests (JSDOM)
└── utils/               # Utility function tests
```

### 7. Naming Conventions

- Test files: `*.test.js` (e.g., `abclass.test.js`)
- Describe blocks: Use descriptive names matching the component/method
- Test names: Should describe the expected behaviour clearly

```javascript
describe('Assignment', () => {
  describe('toJSON', () => {
    it('serialises all properties correctly', () => {
      // test implementation
    });

    it('excludes runtime-only references', () => {
      // test implementation
    });
  });
});
```

### 8. Meaningful Assertions

Write specific, clear assertions:

```javascript
// ✅ Good - specific assertions
expect(result.name).toBe('Expected Name');
expect(result.items).toHaveLength(3);
expect(result.hash).toBeTruthy();
expect(result.hash).toMatch(/^[a-f0-9]{64}$/);

// ❌ Avoid - vague assertions
expect(result).toBeTruthy();
expect(result.items.length > 0).toBe(true);
```

### 9. Test Edge Cases

Always test boundary conditions:

- Empty inputs: `''`, `[]`, `{}`, `null`, `undefined`
- Large inputs: Many items, long strings
- Invalid inputs: Malformed data, wrong types
- Boundary values: 0, -1, max values

### 10. Serialisation Testing Pattern

For any class with `toJSON()`/`fromJSON()`, test the round-trip:

```javascript
it('survives serialisation round-trip', () => {
  const original = createMyModel({ /* ... */ });
  const json = original.toJSON();
  const rehydrated = MyModel.fromJSON(json);
  
  expect(rehydrated).toEqual(original);
  expect(rehydrated.toJSON()).toEqual(json);
});
```

### 11. Hash Stability Testing

For classes that generate hashes, test stability and change detection:

```javascript
it('generates stable hash for same content', () => {
  const obj1 = createMyModel({ content: 'test' });
  const obj2 = createMyModel({ content: 'test' });
  
  expect(obj1.getHash()).toBe(obj2.getHash());
});

it('changes hash when content changes', () => {
  const obj = createMyModel({ content: 'test' });
  const hash1 = obj.getHash();
  
  obj.updateContent('different');
  const hash2 = obj.getHash();
  
  expect(hash2).not.toBe(hash1);
});
```

### 12. UI Template Testing

- Instantiate `JSDOM` to exercise client-side scripts embedded within Apps Script HTML templates (e.g. files in `src/AdminSheet/UI/`).
- Replace templating placeholders (`<?= … ?>`) with fixture data before creating the DOM so that default values mirror production rendering.
- Stub Materialize (`window.M`) and GAS globals (`google.script.run`, `google.script.host`) with chainable mocks that capture success/failure handlers and invocations.
- Dispatch a synthetic `DOMContentLoaded` event after evaluating inline scripts to trigger any on-load wiring.
- Assert against DOM state (class names, styles, input values) and mock invocations rather than relying on Materialize internals.

## Common Patterns

### Testing Singleton Behaviour

```javascript
import { SingletonTestHarness } from '../helpers/singletonTestSetup.js';

describe('MySingleton', () => {
  let harness;

  beforeEach(() => {
    harness = new SingletonTestHarness();
    harness.setupGASMocks();
  });

  afterEach(() => {
    MySingleton.resetForTests();
  });

  it('returns same instance across multiple calls', () => {
    const instance1 = MySingleton.getInstance();
    const instance2 = MySingleton.getInstance();
    
    expect(instance1).toBe(instance2);
  });
});
```

### Testing with Mocked Dependencies

```javascript
import { beforeEach, vi } from 'vitest';

beforeEach(() => {
  globalThis.DbManager = {
    getInstance: vi.fn().mockReturnValue({
      saveClass: vi.fn(),
      loadClass: vi.fn().mockReturnValue(null),
    }),
  };
});
```

### RED Phase Test Pattern

When writing RED phase tests for unimplemented features:

```javascript
describe('Feature Not Yet Implemented', () => {
  it('checks for method existence before testing', () => {
    const instance = new MyClass();
    
    // RED: Method doesn't exist yet
    expect(typeof instance.newMethod).toBe('function');
    
    // Test the expected behavior
    const result = instance.newMethod();
    expect(result).toBe('expected');
  });
});
```

**Key principles for RED phase tests**:
- Add comments like `// RED: Method doesn't exist yet` to document expected failures
- Test method/property existence first to provide clear failure messages
- Test both success paths and error handling
- Include edge cases (null, undefined, empty, corrupt data)
- Verify logging calls for operations
- Clean up mocks in `afterEach` to prevent test pollution

## Anti-Patterns to Avoid

❌ **Don't** call constructors directly if they access GAS services
❌ **Don't** test GAS service behaviour (mock it instead)
❌ **Don't** create production code just for tests
❌ **Don't** use vague assertions like `toBeTruthy()` for complex objects
❌ **Don't** forget to clean up singleton state between tests
❌ **Don't** test implementation details; focus on behaviour

## Quick Reference Commands

```bash
npm test                    # Run all tests once
npm run test:watch          # Run tests in watch mode
npm test -- path/to/file    # Run specific test file
npm test -- -t "pattern"    # Run tests matching name pattern
npm test -- tests/models/   # Run all tests in a directory
```

## Documentation References

Always consult these before writing tests:
- `./docs/developer/testing.md` - Comprehensive testing guide
- `./docs/developer/singletons.md` - Singleton pattern implementation
- `./tests/helpers/` - Available test utilities and factories
- `./tests/setupGlobals.js` - Global test configuration
